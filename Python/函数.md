# 通用函数：
### String
字符串相加可以直接使用加号，同时不同数据类型相加会做相应的转换
```python
a = "Hello" + " " + "Renne"
```
字符串也可以使用函数
* 去除空格
    ``` a.strip() ```
* 字符替换
    ``` a.replace("A", "B") ```
    
### List
python的list变量名存储的是list的指针
```python
thislist = ["apple", "banana", "cherry"]
thislist.insert(1, "orange") #Insert到指定位置
thislist.remove("banana")   #Remove对应值的element
del thislist[0] #Remove指定位置的element
thislist.clear() #清除所有element
thislist = list(("apple", "banana", "cherry")) #用tuple构建list
otherlist = thislist.copy() #内存复制一个list，直接等号赋值会导致两个list变量其实指向同一个list
thislist.extend(otherlist) #通过其他的iterable变量延伸list，otherlist也可以是一个tuple或者其他
thislist.count("apple") #数一下list中有几个叫apple的变量
thislist.index("apple") #返回第一个叫apple变量的index位置
thislist.reverse() #返回反向list的一个新的list
    
```
### Dict
dictionary可用来表示各种object
```python
fromkeys() #返回指定的keys的sub dictionary
items() #返回key&value的tuple
values() #返回所有的value
```

### Iterable & Iterator
Iterator本身是一个object类型，其特征是有.next()的method。在使用"for x in array:"操作的时候，其实是创建了array的iterator的对象，然后每次循环会调用这个iterator的next() method，和"for i in range((0, len(array))):"的调用方式本质上不一样。iterator有__iter__() 和 __next__()方法，掌握之后我们可以自己定义iterator
```python
class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    if self.a <= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration #定义iterator的最终长度
      
myclass = MyNumbers() #创建一个自定义的iterator对象
myiter = iter(myclass) #iter()这里的myiter继承了类MyNumbers的一些属性
type(myiter) #<class 'MyNumbers'>, 这里发现type并没有改变，但是其本身多了iterator的method
print(myclass is myiter) # True，其实等价

for x in myiter:
  print(x)
#在这里，myiter没有list的method，但是有iterator的method，因此不能用数组去调用，而是用iterator的方法调用。好处是每次调用仅仅产生一个value，并没有list所谓的缓存值，因为这个iterator的next()值来源一数学操作，而list的iterator值可能来源于内存计算。
```

# 函数库
### numpy
numpy的array其实就是对python自带的array做了封装，支持一些矩阵运算操作，并且这些矩阵运算操作涉及到了一些优化，numpy的array可以和python自己的array互相转化




