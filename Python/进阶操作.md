## 函数传参 pass by assignment
理解python的最基本的函数传参，在python中，只有一种传参方式叫pass by assignment。在python中，所有的变量都是object，整数变量也是，不同的整数变量等价于不同的object(比如2333和6666就是不同的object)，这种object是不可变(immutable)的。而加减乘除的操作，其实是将一个变量名引导去了不同的object。而对于list，dict这种object就是可以变的(mutable)，大部分的类型都是可变的。不可变的objet有：
* numbers
* booleans
* strings
* tuples
* frozensets
```python
#这是一个函数的例子
my_var = 25
def my_method(v):
    v += 10
    return v
    
#这个例子等价于下面的几个句子：
my_var = 25
v = my_var # 即在传参的那个步骤，用等号赋值，assignment的意思就是等号赋值
v += 10  # This is identical to v = v + 10
```
而pass by assignment的意思来源于一个object是否是mutable的，等号在immutable的object赋值的时候，是完全等价赋值，而在mutable的object赋值的时候，是引用赋值，区别来源于' = '符号的用法。同时这种赋值的方法是不可以改变的(暂时看是这样)。

## 多类型参数 \*args and \*\*kwargs
通常情况下，python和其他语言的函数，给定的参数值是固定的，即使是有默认参数，也是需要申明的
```
def adder(x,y,z=13):
    print("sum:",x+y+z)
adder(11,12) # 输出36
```
而python是可以pass不定量的parameter进入函数的，这就要使用arg和kwarg
* \*args (Non Keyword Arguments)
* \*\*kwargs (Keyword Arguments)



## 列举和print的区别
在一些编译器中，比如jupyter的解释器，直接列举某个变量可以达到print的效果
```
a = 10
a # 输出 10
```
但是这个列举和print其实是不一样的，print会print对应的对象的str转化类型，即__str__的输出，而列举调用的是类里面的__repr__函数对象
```python
class Renne():
    def __init__(self):
        self.word = "Hello Renne"
        
    def __str__(self):
         return self.word
         
    def __repr__(self):
        return "2333"

r = Renne()
print(r) # “Hello Renne”，实际为call back函数__str__的输出结果，即类Renne()对str的默认转化函数
r # 2333
```
这两个函数本身默认都是没有重载的，如果对于一个类，这两个函数都没有的话，那么就会输出内存的位置，如”<\_\_main\_\_.Renne at 0x7f76500b54e0>“



## Alias & overload
python的等号赋值都是重名(alias)，实际传递参数是引用传递。
* 对于整数小数字符串等，等号赋值在内存上指向同一个constant的位置
* 对于类的，等号赋值等价于指针赋值，同样指向相同的类
同时，python本来的一些关键词也可以被alias，这种时候相当于你overload了这个name，比如
```python
def fun(a, b, range):
    for i in range(range):
        # do sth
# 这个函数运行的时候会产生error，因为range这个关键词在传进来的时候被重载，可能不再是一个函数的类型
```


## String前缀
python的string底层的编码可以理解为都是16进制的编码（而16进制其实又是0101），用'\x00'来表示，不同的编码方式会影响某些函数的结果（比如print函数）。python的string定义前可以添加prefix前缀，（如s = u'abc'），不同前缀有不同的意义。
1.  u前缀表示unicode，以Unicode字符来存储字符串。在python3中，字符串的存储方式中，不管前缀带不带u，默认方式都是unicode编码的字符串。
2.  r前缀表示raw string，不识别转义，即不能识别像'\n'这样的特殊字符，而是成为纯粹的字符串，如 r"test\ntest"的输出就是 r"test\ntest"，不会有换行出现
```python
b = r"test\ntest"     
print(b) # test\ntest
```
3.  b前缀表示bytearray，生成字节序列对象，类型为bytes，可以理解为用bytes编码的字符串，本身是bytes，而print函数会将其字符串的部分显示出来，在socket中使用的比较多，并且bytes类型只可以是ASCII的字符或者16进制字符。
```
s = b"\x63\x67" #等价于 b"cg"，十六进制用ASCII解码。
```
4.  f前缀表示format，用来格式化字符串。即可以实现变量名对字符串的插入方式，类似string的加法
```python
age = 38
name = "Annie"
print(f'his name is {name},{age} years old') #his name is Annie,38 years old
```
而这些前缀之间某些可以用encode来转化
1. encode将一个string用bytes的方式来编码，通常使用的是utf-8和gbk，utf-8全称为”8-bit Unicode Transformation Format“
``` python
s0 = "好".encode("utf-8") #三个十六进制数表示一个字符
s1 = "好".encode("gbk") #两个十六进制数表示一个字符
print(s0) # b'\xe5\xa5\xbd'
print(s1) # b'\xba\xc3'
test = u'\u50c0' #把一个unicode编码的字符串赋值给一个unicode的string
print(test) # 输出'僀'，得到一个对应的奇怪的文字
```



## 对一个list中所有元素apply某个函数
```python
list1 = [x.fun() for x in list0]
```


## Super() init
用于类的继承，即子类在初始化的时候，调用父类的constructor，super()这个函数在单一层次继承和直接Base.\_\_init\_\_意思一样，在大于两个类的继承的时候，super比直接写要更加明确，推荐使用
```python
class Base(object):
    def __init__(self):
        print "Base created"

class ChildA(Base):
    def __init__(self):
        Base.__init__(self)

class ChildB(Base):
    def __init__(self):
        #super(ChildB, self).__init__() in python 2
        super().__init__() #in python 3
        
ChildA() 
ChildB()
```
