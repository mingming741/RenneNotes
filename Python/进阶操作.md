# 0. 简介
让我们的code更加Pythonic，这个网站上面有详细的教程<a href="http://book.pythontips.com/en/latest/index.html">Python tips</a>

# 1. Function 
### 1.1 函数传参 pass by assignment
理解python的最基本的函数传参，在python中，只有一种传参方式叫pass by assignment。在python中，所有的变量都是object，整数变量也是，不同的整数变量等价于不同的object(比如2333和6666就是不同的object)，这种object是不可变(immutable)的。而加减乘除的操作，其实是将一个变量名引导去了不同的object。而对于list，dict这种object就是可以变的(mutable)，大部分的类型都是可变的。不可变的objet有：
* numbers
* booleans
* strings
* tuples
* frozensets
```python
#这是一个函数的例子
my_var = 25
def my_method(v):
    v += 10
    return v
    
#这个例子等价于下面的几个句子：
my_var = 25
v = my_var # 即在传参的那个步骤，用等号赋值，assignment的意思就是等号赋值
v += 10  # This is identical to v = v + 10
```
而pass by assignment的意思来源于一个object是否是mutable的，等号在immutable的object赋值的时候，是完全等价赋值，而在mutable的object赋值的时候，是引用赋值，区别来源于' = '符号的用法。同时这种赋值的方法是不可以改变的(暂时看是这样)。

### 1.2 多类型参数 \*args and \*\*kwargs
通常情况下，python和其他语言的函数，给定的参数值是固定的，即使是有默认参数，也是需要申明的，而python是可以pass不定量的parameter进入函数的，这就要使用arg和kwarg
    * \*args (Non Keyword Arguments)
    * \*\*kwargs (Keyword Arguments)
```
def adder(x,y,z=13):
    print("sum:",x+y+z)
adder(11,12) # 输出36
```
先给Non Keyword Arguments，在申明\*num的时候，num会把所有的没有指定值的值(比如3，True，这种叫没有指定值)加入num这个list(tuple?)，在函数之内就可以用iterator来遍历这些值
```python
def adder(*num):
    sum = 0
    for n in num:
        sum = sum + n
    print("Sum:",sum)
adder(3,5,7,9) # 24
```
而Keyword Arguments就是将有申明的指定值(比如number=3，isGood=False，这些值)生成一个dictionary
```python
def intro(**data):
    print("\nData type of argument:",type(data))
    for key, value in data.items():
        print("{} is {}".format(key,value))
intro(Firstname="Sita", Lastname="Sharma", Age=22, Phone=1234567890)
```
当这两个都被使用的时候，python的函数就可以接受任意数量的parameter了。<br/>
同时，函数本身传入的list，也可以通过引用传入转化为\*arg所接受的参数，这种写法等于在list(或者是其他iterable)被传入函数然后展开的时候，避免其展开而成为参数
```
# 构建神经网络的架构的时候，因为nn.Sequential()只支持多参数输入
modulelist = [nn.Linear(3, 2), nn.Tanh(), nn.Linear(2, 3)]
nn.Sequential(*modulelist)
```

### 1.3 装饰器Decorators
装饰器是"functions which modify the functionality of other functions"，python的函数也是object，而函数本身可以赋值给其他函数
```
def hi(name="Renne"):
    return "hi " + name
print(hi()) # hi Renne
greet = hi # 区别与greet = hi()，这不是赋值返回值，而是赋值变量
print(greet()) # hi Renne
del hi
try:
    print(hi())
except NameError:
    print(2333) # 2333
print(greet())  # hi Renne， 这里还是会有输出，删除hi这个名称并不会删除这个函数的object
```
同时，python的函数是可以nest操作的，并且函数可以返回函数本身
```
def hi(name="Renne"):
    def greet():
        return "now you are in the greet() function"
    def welcome():
        return "now you are in the welcome() function"
    if name == "Renne":
        return greet
    else:
        return welcome
        
print(a) # <function greet at 0x7f2143c01500>， 返回函数本身
print(a()) # now you are in the greet() function， 返回函数的返回值
```
函数也可以作为其他函数的parameter，成为input
```
def hi():
    return "hi Renne!"
def doSomethingBeforeHi(func):
    print(func())
doSomethingBeforeHi(hi) # hi Renne!， fun()的这个括号操作，等价于取得函数变量的返回值操作
```
而装饰器可以理解为一个装饰器函数，装饰器函数会接受被装饰函数作为input，modify函数本身之后，再返回被装饰的函数，例如
```
def a_new_decorator(a_func):
    def wrapTheFunction():
        print("Deco1")
        a_func()
        print("Deco2")
    return wrapTheFunction

def a_function_requiring_decoration():
    print("Func")

a_function_requiring_decoration() # Func
a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)
a_function_requiring_decoration() # Deco1 Func Deco2, 这个函数被装饰器改变了
```
但是这个操作会override原来的函数的__name__ attribute和docstring，所以通常使用外部的库functools.wraps来替我们做装饰，
```
from functools import wraps
def a_new_decorator(a_func):
    @wraps(a_func) # 这句话用来取出override的部分
    def wrapTheFunction():
        print("Deco1")
        a_func()
        print("Deco2")
    return wrapTheFunctio

def a_function_requiring_decoration():
    print("Func")

a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)
print(a_function_requiring_decoration.__name__) # a_function_requiring_decoration, 否则会输出wrapTheFunction
```
最后提一下Decorators的use case，因为Decorators本质是在原函数基础上添加的操作，所以用作Authorization， Logging的时候，非常的有效。同时，decorator还可以带参数，这里给出log的一个例子
```
from functools import wraps
def logit(logfile='out.log'):
    def logging_decorator(func):
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + " was called"
            print(log_string)
            # Open the logfile and append
            with open(logfile, 'a') as opened_file:
                # Now we log to the specified logfile
                opened_file.write(log_string + '\n')
        return wrapped_function
    return logging_decorator

@logit()
def myfunc1():
    pass

myfunc1()
# Output: myfunc1 was called
# A file called out.log now exists, with the above string

@logit(logfile='func2.log')
def myfunc2():
    pass

myfunc2()
# Output: myfunc2 was called
# A file called func2.log now exists, with the above string
```


# 2. Class
### 2.1 列举和print的区别
在一些编译器中，比如jupyter的解释器，直接列举某个变量可以达到print的效果
```
a = 10
a # 输出 10
```
但是这个列举和print其实是不一样的，print会print对应的对象的str转化类型，即__str__的输出，而列举调用的是类里面的__repr__函数对象
```python
class Renne():
    def __init__(self):
        self.word = "Hello Renne"
        
    def __str__(self):
         return self.word
         
    def __repr__(self):
        return "2333"

r = Renne()
print(r) # “Hello Renne”，实际为call back函数__str__的输出结果，即类Renne()对str的默认转化函数
r # 2333
```
这两个函数本身默认都是没有重载的，如果对于一个类，这两个函数都没有的话，那么就会输出内存的位置，如”<\_\_main\_\_.Renne at 0x7f76500b54e0>“

### 2.2 Alias & overload
python的等号赋值都是重名(alias)，实际传递参数是引用传递。
* 对于整数小数字符串等，等号赋值在内存上指向同一个constant的位置
* 对于类的，等号赋值等价于指针赋值，同样指向相同的类
同时，python本来的一些关键词也可以被alias，这种时候相当于你overload了这个name，比如
```python
def fun(a, b, range):
    for i in range(range):
        # do sth
# 这个函数运行的时候会产生error，因为range这个关键词在传进来的时候被重载，可能不再是一个函数的类型
```

### 2.3 Super() init
用于类的继承，即子类在初始化的时候，调用父类的constructor，super()这个函数在单一层次继承和直接Base.\_\_init\_\_意思一样，在大于两个类的继承的时候，super比直接写要更加明确，推荐使用
```python
class Base(object):
    def __init__(self):
        print "Base created"

class ChildA(Base):
    def __init__(self):
        Base.__init__(self)

class ChildB(Base):
    def __init__(self):
        #super(ChildB, self).__init__() in python 2
        super().__init__() #in python 3
        
ChildA() 
ChildB()
```

# 3. Operations
### 3.1 String前缀
python的string底层的编码可以理解为都是16进制的编码（而16进制其实又是0101），用'\x00'来表示，不同的编码方式会影响某些函数的结果（比如print函数）。python的string定义前可以添加prefix前缀，（如s = u'abc'），不同前缀有不同的意义。
1.  u前缀表示unicode，以Unicode字符来存储字符串。在python3中，字符串的存储方式中，不管前缀带不带u，默认方式都是unicode编码的字符串。
2.  r前缀表示raw string，不识别转义，即不能识别像'\n'这样的特殊字符，而是成为纯粹的字符串，如 r"test\ntest"的输出就是 r"test\ntest"，不会有换行出现
```python
b = r"test\ntest"     
print(b) # test\ntest
```
3.  b前缀表示bytearray，生成字节序列对象，类型为bytes，可以理解为用bytes编码的字符串，本身是bytes，而print函数会将其字符串的部分显示出来，在socket中使用的比较多，并且bytes类型只可以是ASCII的字符或者16进制字符。
```
s = b"\x63\x67" #等价于 b"cg"，十六进制用ASCII解码。
```
4.  f前缀表示format，用来格式化字符串。即可以实现变量名对字符串的插入方式，类似string的加法
```python
age = 38
name = "Annie"
print(f'his name is {name},{age} years old') #his name is Annie,38 years old
```
而这些前缀之间某些可以用encode来转化
1. encode将一个string用bytes的方式来编码，通常使用的是utf-8和gbk，utf-8全称为”8-bit Unicode Transformation Format“
``` python
s0 = "好".encode("utf-8") #三个十六进制数表示一个字符
s1 = "好".encode("gbk") #两个十六进制数表示一个字符
print(s0) # b'\xe5\xa5\xbd'
print(s1) # b'\xba\xc3'
test = u'\u50c0' #把一个unicode编码的字符串赋值给一个unicode的string
print(test) # 输出'僀'，得到一个对应的奇怪的文字
```

### 3.2 对一个list中所有元素apply某个函数
```python
list1 = [x.fun() for x in list0]
```


